>参考：
>
>- [干货 | Merkle Patricia Tree 详解 » EthFans | 以太坊爱好者](https://ethfans.org/toya/articles/588)
>- [eth.wiki](https://eth.wiki/en/fundamentals/patricia-tree)
>- [Ethereum Merkle Patricia Trie Explained | by Leo Zhang | Medium](https://medium.com/@chiqing/merkle-patricia-trie-explained-ae3ac6a7e123)

Merkle Patricia Tree（又称为Merkle Patricia Trie，简称MPT）是一种经过改良的、融合了Merkle tree和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

MPT有几个作用：

- 存储任意长度的key-value键值对数据
- 提供了一种快速计算所维护数据集哈希标识的机制；
- 提供了快速状态回滚的机制；
- 提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证；



### Radix Trie

Trie树，又称**前缀树或字典树**，是一种有序树，用于保存关联数组。常见的用来存英文单词的Trie中，每个结点是一个长度为 27 的指针数组，index 0-25分别代表 a-z 字符，26则代表节点标志域，表示该结点是否是一个完整的字符串。如下图所示：

![img](https://pic4.zhimg.com/80/v2-07a263568193a61ed457ea441a69513f_1440w.jpg)

从根结点出发，沿着指针路径到达某个结点所形成的字符串为该结点所代表的字符串，如果标志域有记录，则表示该字符串作为一个完整的串被插入到 Trie 中。这个字符串，就表示键值。

容易发现，一般情况下不是所有的结点都有对应的值，只有标志域有记录的点才表示完整的字符串，即键值。

#### 优势

相比于哈希表，使用前缀树来进行查询拥有共同前缀 key 的数据时十分高效。比如要在字典中查询以 pre 作为前缀的单词，那么哈希表需要 以 $O(n)$ 的时间效率遍历整张表，而对于前缀树仅需先找到前缀 pre 代表的结点，然后以该结点为根的子树查询即可。

另外，相比于哈希表，在前缀树中查询不会存在哈希冲突的问题。

#### 劣势

在前缀树中直接查询一个长度为 m 的 key，复杂度为 $O(m)$，并且需要进行 $O(m)$  次 IO开销。而哈希表的查找复杂度为 $O(1)$，所以前缀树中做直接查询，不仅速度慢，磁盘压力也很大。

前面提到 Trie 中会有很多不存在 Key 值的结点，这会造成空间的浪费。有时需要创建许多过渡结点来存放 Key。



### Patricia Trie

Patricia Trie 仅仅是对 Trie 的一种优化。对于 Trie 中的每个节点，如果该节点是其父亲节点唯一的儿子的话，那么该节点就可以和父节点合并。不仅优化了空间，还在一定程度上优化了直接查询的时间。

![img](https://pic1.zhimg.com/80/v2-932c5c442939901fa4259789029eb190_1440w.jpg)

### Merkle Tree

Merkle Tree 是一种树，大多种情况下可以使用二叉树实现，当然也可以使用多叉树。

Merkle Tree 的叶子节点存放数据项的具体内容或者是数据项的哈希值。非叶子节点存放的值由它的子节点计算得来。在二叉树的实现中，可以将非叶子节点的两个儿子节点的哈希值合并成一个字符串，再进行哈希得到该节点存放的内容。

如果某个非叶结点仅有一个儿子，那么这种情况有着不同的处理办法，可以采取复制补齐，亦或者直接在单个节点上哈希。

如果两颗Merkle Tree 的根哈希值一致，那么这两棵树的结构、节点的内容必然相同。

#### 优势

##### 快速重哈希

当树节点内容发生变化，仅仅需要把它的所有祖先节点重新计算哈希即可，不需要整个树都重新计算。

##### 轻节点扩展

采用Merkle tree，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

对于轻节点来说，验证一条交易只需要验证包含该交易的路径即可，并不需要把所有交易的Hash全部重新算一遍。

![img](https://pic1.zhimg.com/80/v2-1acfb4f6da08977b33ee75e349f83d88_1440w.jpg)

#### 劣势

存储空间开销大



### MPT（Merkle Patricia Trees）

相关概念：

- 世界状态：在以太坊中，所有账户（包括合约账户、普通账户）的状态数据统称为世界状态；
- 轻节点：指只存储区块头数据的区块链节点；
- 区块链分叉：指向同一个父块的两个区块被同时生成的情况，某些部分的矿工看到其中一个区块，其他的矿工则看到另外一个区块。这导致2种区块链同时增长；
- 区块头：指以太坊区块结构体的一部分，用于存储该区块的头部信息，如父区块哈希、世界状态哈希、交易回执集合哈希等。区块头仅存储一些“固定”长度的哈希字段；

MPT树中的节点：

- 空节点（NULL）：简单的表示空，在代码中是一个空串。

- 叶子结点（Leaf）：一个包含键值对的结点 <key,value>，其中 key是 key 的一种特殊十六进制编码(MP编码)， value是value的RLP编码。

- 分支结点（Branch）：一个包含 17 个子项的结点 $[v_0,\cdots,v_{15}, v_t]$

    因为 MPT 树中的 key 被编码为一种特殊的 16 进制数字，在加上最后的 value，所以分支结点是一个长度为 17 的list。前16个元素对应着key中的16个可能的十六进制字符 ， 如果有一 <key,value>对在这个分支节点终止，最后一个元素代表一个值 ，即分支节点既可以搜索路径的终止也可以是路径的中间节点。

- 扩展结点：也是 <key,value> 的一个键值对，但是这里的 value 是其他结点的哈希值，这个哈希可以被用来查询数据库中的节点。也就是说，通过hash来链接到其他节点。

因此，MPT树中有两种 <key,value> 的节点。

#### 以太坊中对 Key 的编码

在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求。

三种编码方式分别为：

1. Raw编码（原生的字符）；
2. Hex编码（扩展的16进制编码）；
3. Hex-Prefix编码（16进制前缀编码）；

##### Raw 编码

Raw 编码即原生的 key 值，不作任何改变。这种编码方式的 key，是MPT对外提供接口的默认编码方式。

例如一条key为“cat”，value为“dog”的数据项，其key的Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]（Hex）

##### Hex 编码

Hex 编码将一个 8 位的字节数据用两个十六进制数字展示出来。首先，将 8 位二进制码分组为两个 4 位的二进制码，然后这两个 4 位的二进制码高 4 位都补 0 变成两个 8 位的二进制码，最后输出这两个 8 位二进制码所对应的十六进制数字作为编码。

例如：A（65）对饮的二进制码：0100 0001，重新分组后：0000 0100，0000 0001，对应到十六进制为 41。

在MPT树上，如果该 Key 对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为 16 的字符作为 Terminator。否则，不做任何修改。

##### Hex-Prefix 编码（HP编码）

目的：

- 在MPT树中，区分叶子节点与扩展节点
- 把奇数路径变为偶数路径

步骤：

- 如果有Treminator（16），那么就去掉
- 根据表格加上 Prefix

```txt
node type    path length    |    prefix    hexchar
--------------------------------------------------
extension    even           |    0000      0x0
extension    odd            |    0001      0x1
leaf         even           |    0010      0x2
leaf         odd            |    0011      0x3
```

如果最终得到的前缀是 0x0 或者是 0x2，那么就再补一个0，变成 0x00，0x20。这样做可以保证路径长度为偶数。

例如：

```
[ 0, f, 1, c, b, 8, 16] -> '20 0f 1c b8'
```

末尾字符 “16” 说明了该节点是一个叶子节点，然后前缀加上 0x20。



##### 编码转换关系

- Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；
- Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；
- HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；

![img](https://pic3.zhimg.com/80/v2-232537cfac5103618cb9b0b45e9a47e2_1440w.jpg)

#### MPT的结构

MPT树的特点如下:

- 叶子节点和分支节点可以保存value，扩展节点保存key；
- 没有公共的key就成为2个叶子节点；key1=[1,2,3] key2=[2,2,3]
- 有公共的key需要提取为一个扩展节点；key1=[1,2,3] key2=[1,3,3] => ex-node=[1],下一级分支node的key
- 如果公共的key也是一个完整的key，数据保存到下一级的分支节点中；key1=[1,2] key2=[1,2,3] =>ex-node=[1,2],下一级分支node的key; 下一级分支=[3],上一级key对应的value

简单的结构如下图：

![img](https://pic4.zhimg.com/80/v2-e2698781750973ae4a083f3dbe8bb517_1440w.jpg)

